<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XM8 Professional - Real Detection</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@latest"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .status-bar {
            background: rgba(34, 197, 94, 0.2);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #22c55e;
            text-align: center;
        }

        .camera-container {
            position: relative;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(10px);
            margin-bottom: 20px;
        }

        #videoContainer {
            position: relative;
            width: 100%;
            max-width: 640px;
            margin: 0 auto;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        #video {
            width: 100%;
            height: auto;
            display: block;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .controls {
            text-align: center;
            margin: 20px 0;
        }

        #status {
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #captureBtn {
            background: linear-gradient(45deg, #22c55e, #16a34a);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            font-weight: 600;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(34, 197, 94, 0.4);
            display: none;
        }

        #captureBtn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(34, 197, 94, 0.6);
        }

        #captureBtn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .detection-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 15px 0;
            display: none;
        }

        .info-box {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .info-box label {
            display: block;
            font-size: 0.8em;
            color: #a3e635;
            margin-bottom: 5px;
        }

        .info-box value {
            font-size: 1.1em;
            font-weight: 600;
        }

        .error {
            background: rgba(239, 68, 68, 0.2);
            color: #fecaca;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            border-left: 4px solid #ef4444;
            display: none;
        }

        .results {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            backdrop-filter: blur(10px);
            display: none;
        }

        .results h3 {
            color: #22c55e;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .result-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .result-item {
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #22c55e;
        }

        .result-item label {
            font-weight: 600;
            color: #a3e635;
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .result-item .value {
            font-size: 1.1em;
            line-height: 1.4;
            font-family: 'Courier New', monospace;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: #22c55e;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .manual-input {
            background: rgba(255, 191, 36, 0.1);
            border: 2px solid #fbbf24;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .manual-input h4 {
            color: #fbbf24;
            margin-bottom: 15px;
        }

        .manual-input input {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 5px;
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 1em;
            margin: 5px 0;
        }

        .manual-input input::placeholder {
            color: rgba(255,255,255,0.5);
        }

        .manual-btn {
            background: linear-gradient(45deg, #fbbf24, #f59e0b);
            color: black;
            border: none;
            padding: 10px 20px;
            font-size: 1em;
            font-weight: 600;
            border-radius: 25px;
            cursor: pointer;
            margin-top: 10px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .result-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîç XM8 Professional Detection</h1>
            <p>Real-time object detection with dynamic tracking + manual override</p>
        </div>

        <div class="status-bar">
            <strong>‚úÖ WORKING:</strong> Dynamic green boxes that adjust to objects + Enhanced item database + Manual override for unlimited items
        </div>

        <div class="camera-container">
            <div id="videoContainer">
                <video id="video" autoplay playsinline></video>
                <canvas id="canvas"></canvas>
            </div>
            
            <div class="controls">
                <div id="status">üöÄ Initializing camera and AI model...</div>
                
                <div class="detection-info" id="detectionInfo">
                    <div class="info-box">
                        <label>Detected Item:</label>
                        <value id="detectedItem">None</value>
                    </div>
                    <div class="info-box">
                        <label>Confidence:</label>
                        <value id="confidence">0%</value>
                    </div>
                    <div class="info-box">
                        <label>Stability:</label>
                        <value id="stability">0/5</value>
                    </div>
                    <div class="info-box">
                        <label>Box Color:</label>
                        <value id="boxColor">Scanning</value>
                    </div>
                </div>
                
                <button id="captureBtn" onclick="captureAndAnalyze()">Analyze Detected Item</button>
            </div>
        </div>

        <div class="manual-input">
            <h4>üñäÔ∏è Can't detect your item? Manual override:</h4>
            <input type="text" id="manualItem" placeholder="Enter item name (e.g., baseball hat, hammer, printer)" />
            <br>
            <button class="manual-btn" onclick="analyzeManualItem()">Get XACTIMATE Codes</button>
        </div>

        <div id="error" class="error"></div>

        <div id="results" class="results">
            <h3>üéØ Professional Analysis Results</h3>
            <div id="resultsContent" class="result-grid"></div>
        </div>
    </div>

    <script>
        // Global variables
        let model;
        let video;
        let canvas;
        let ctx;
        let isCapturing = false;
        let detectionInterval;

        // Enhanced detection variables
        let stableDetections = [];
        let currentDetection = null;
        const STABILITY_THRESHOLD = 5;
        const CONFIDENCE_THRESHOLD = 0.4;
        const SMOOTHING_FACTOR = 0.3;

        // Initialize
        async function init() {
            video = document.getElementById('video');
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');

            await initializeCamera();
            await loadModel();
            startDetectionLoop();
        }

        async function initializeCamera() {
            const statusEl = document.getElementById('status');
            const errorEl = document.getElementById('error');
            
            try {
                statusEl.textContent = 'üì∑ Starting camera...';
                errorEl.style.display = 'none';
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
                
                video.srcObject = stream;
                
                video.onloadeddata = () => {
                    // Set canvas to match video size
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    statusEl.textContent = 'ü§ñ Loading AI model...';
                };
                
                return true;
                
            } catch (error) {
                console.error('Camera error:', error);
                let errorMessage = 'Camera Error: ';
                
                if (error.name === 'NotAllowedError') {
                    errorMessage += 'Camera access denied. Please allow camera permission.';
                } else if (error.name === 'NotFoundError') {
                    errorMessage += 'No camera found. Please check your device.';
                } else {
                    errorMessage += error.message;
                }
                
                statusEl.textContent = 'Camera failed';
                errorEl.textContent = errorMessage;
                errorEl.style.display = 'block';
                return false;
            }
        }

        async function loadModel() {
            const statusEl = document.getElementById('status');
            const errorEl = document.getElementById('error');
            
            try {
                statusEl.innerHTML = 'ü§ñ Loading AI model... <div class="loading"></div>';
                model = await cocoSsd.load();
                statusEl.textContent = '‚úÖ Ready! Point camera at items to detect with dynamic boxes';
                console.log('COCO-SSD model loaded successfully');
                return true;
            } catch (error) {
                console.error('Model loading failed:', error);
                statusEl.textContent = 'AI model failed to load';
                errorEl.textContent = `Model Error: ${error.message}. Please refresh the page.`;
                errorEl.style.display = 'block';
                return false;
            }
        }

        function startDetectionLoop() {
            if (detectionInterval) clearInterval(detectionInterval);
            
            detectionInterval = setInterval(async () => {
                if (model && video && !isCapturing) {
                    await detectObjects();
                }
            }, 100); // 10 FPS
        }

        async function detectObjects() {
            try {
                const predictions = await model.detect(video);
                const detectionInfoEl = document.getElementById('detectionInfo');
                
                if (predictions && predictions.length > 0) {
                    // Find the most confident and centered detection
                    const centerX = video.videoWidth / 2;
                    const centerY = video.videoHeight / 2;
                    
                    let bestDetection = null;
                    let bestScore = 0;
                    
                    for (const prediction of predictions) {
                        if (prediction.score > CONFIDENCE_THRESHOLD) {
                            const [x, y, width, height] = prediction.bbox;
                            const objCenterX = x + width / 2;
                            const objCenterY = y + height / 2;
                            
                            // Distance from center
                            const distance = Math.sqrt(
                                Math.pow(objCenterX - centerX, 2) + 
                                Math.pow(objCenterY - centerY, 2)
                            );
                            
                            // Combined score: confidence - distance penalty
                            const combinedScore = prediction.score - (distance / 1000);
                            
                            if (combinedScore > bestScore) {
                                bestScore = combinedScore;
                                bestDetection = prediction;
                            }
                        }
                    }
                    
                    if (bestDetection) {
                        // Smooth the detection if we have a previous one
                        if (currentDetection && currentDetection.class === bestDetection.class) {
                            bestDetection.bbox = smoothBoundingBox(currentDetection.bbox, bestDetection.bbox);
                        }
                        
                        currentDetection = bestDetection;
                        stableDetections.push(bestDetection);
                        
                        // Keep only recent detections
                        if (stableDetections.length > STABILITY_THRESHOLD) {
                            stableDetections.shift();
                        }
                        
                        // Update display
                        drawDetection(bestDetection);
                        updateDetectionInfo(bestDetection);
                        detectionInfoEl.style.display = 'grid';
                        
                        // Show capture button if stable
                        const captureBtn = document.getElementById('captureBtn');
                        const statusEl = document.getElementById('status');
                        
                        if (stableDetections.length >= STABILITY_THRESHOLD) {
                            captureBtn.style.display = 'block';
                            statusEl.textContent = `üéØ ${bestDetection.class.toUpperCase()} locked with green box - Ready to analyze!`;
                        } else {
                            captureBtn.style.display = 'none';
                            const progress = Math.round((stableDetections.length / STABILITY_THRESHOLD) * 100);
                            statusEl.textContent = `üîç Stabilizing ${bestDetection.class}... ${progress}%`;
                        }
                    } else {
                        resetDetection();
                    }
                } else {
                    resetDetection();
                }
                
            } catch (error) {
                console.error('Detection error:', error);
                document.getElementById('status').textContent = 'Detection error - retrying...';
            }
        }

        function smoothBoundingBox(oldBox, newBox) {
            return [
                oldBox[0] + (newBox[0] - oldBox[0]) * SMOOTHING_FACTOR,
                oldBox[1] + (newBox[1] - oldBox[1]) * SMOOTHING_FACTOR,
                oldBox[2] + (newBox[2] - oldBox[2]) * SMOOTHING_FACTOR,
                oldBox[3] + (newBox[3] - oldBox[3]) * SMOOTHING_FACTOR
            ];
        }

        function drawDetection(detection) {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const [x, y, width, height] = detection.bbox;
            const confidence = Math.round(detection.score * 100);
            const stability = stableDetections.length;
            
            // Determine color based on stability - THE GREEN BOXES YOU WANTED!
            let color, colorName;
            if (stability >= STABILITY_THRESHOLD) {
                color = '#22c55e'; // GREEN - ready
                colorName = 'Green (Ready)';
            } else if (stability >= 3) {
                color = '#eab308'; // YELLOW - getting stable
                colorName = 'Yellow (Stabilizing)';
            } else {
                color = '#f59e0b'; // ORANGE - just detected
                colorName = 'Orange (Detecting)';
            }
            
            // Draw THE DYNAMIC BOX that adjusts to object size
            ctx.strokeStyle = color;
            ctx.fillStyle = color + '25'; // Semi-transparent fill
            ctx.lineWidth = 4;
            
            // Fill and stroke the rectangle that MATCHES the object
            ctx.fillRect(x, y, width, height);
            ctx.strokeRect(x, y, width, height);
            
            // Draw corner indicators
            const cornerSize = Math.min(width, height) * 0.1;
            ctx.lineWidth = 6;
            
            // Top-left
            ctx.beginPath();
            ctx.moveTo(x, y + cornerSize);
            ctx.lineTo(x, y);
            ctx.lineTo(x + cornerSize, y);
            ctx.stroke();
            
            // Top-right
            ctx.beginPath();
            ctx.moveTo(x + width - cornerSize, y);
            ctx.lineTo(x + width, y);
            ctx.lineTo(x + width, y + cornerSize);
            ctx.stroke();
            
            // Bottom-left
            ctx.beginPath();
            ctx.moveTo(x, y + height - cornerSize);
            ctx.lineTo(x, y + height);
            ctx.lineTo(x + cornerSize, y + height);
            ctx.stroke();
            
            // Bottom-right
            ctx.beginPath();
            ctx.moveTo(x + width - cornerSize, y + height);
            ctx.lineTo(x + width, y + height);
            ctx.lineTo(x + width, y + height - cornerSize);
            ctx.stroke();
            
            // Draw center crosshair
            const centerX = x + width / 2;
            const centerY = y + height / 2;
            const crossSize = Math.min(width, height) * 0.08;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX - crossSize, centerY);
            ctx.lineTo(centerX + crossSize, centerY);
            ctx.moveTo(centerX, centerY - crossSize);
            ctx.lineTo(centerX, centerY + crossSize);
            ctx.stroke();
            
            // Draw label
            const label = `${detection.class.toUpperCase()} - ${confidence}%`;
            const labelY = y > 35 ? y - 15 : y + height + 30;
            
            // Label background
            const textWidth = ctx.measureText(label).width;
            ctx.fillStyle = color;
            ctx.fillRect(x - 3, labelY - 25, textWidth + 12, 30);
            
            // Label text
            ctx.fillStyle = 'white';
            ctx.font = 'bold 16px Arial';
            ctx.fillText(label, x + 3, labelY - 5);
            
            // Store color name for info display
            document.getElementById('boxColor').textContent = colorName;
        }

        function updateDetectionInfo(detection) {
            document.getElementById('detectedItem').textContent = detection.class;
            document.getElementById('confidence').textContent = Math.round(detection.score * 100) + '%';
            document.getElementById('stability').textContent = `${stableDetections.length}/${STABILITY_THRESHOLD}`;
        }

        function resetDetection() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            stableDetections = [];
            currentDetection = null;
            document.getElementById('captureBtn').style.display = 'none';
            document.getElementById('detectionInfo').style.display = 'none';
            document.getElementById('status').textContent = 'üîç Scanning for objects... Point camera at items';
        }

        async function captureAndAnalyze() {
            if (!currentDetection || isCapturing) return;
            
            isCapturing = true;
            const captureBtn = document.getElementById('captureBtn');
            const statusEl = document.getElementById('status');
            
            try {
                captureBtn.textContent = 'Analyzing...';
                captureBtn.disabled = true;
                statusEl.textContent = 'üì∏ Analyzing detected item...';
                
                // Simulate analysis time
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Generate enhanced analysis
                const analysis = generateEnhancedAnalysis(currentDetection);
                
                statusEl.textContent = '‚úÖ Analysis complete!';
                displayResults(analysis);
                
            } catch (error) {
                console.error('Analysis error:', error);
                statusEl.textContent = 'Analysis failed - try again';
            } finally {
                isCapturing = false;
                captureBtn.textContent = 'Analyze Detected Item';
                captureBtn.disabled = false;
            }
        }

        function analyzeManualItem() {
            const manualItem = document.getElementById('manualItem').value.trim();
            if (!manualItem) {
                alert('Please enter an item name');
                return;
            }
            
            const analysis = generateEnhancedAnalysis({ 
                class: manualItem, 
                score: 1.0 
            }, true);
            
            displayResults(analysis);
            document.getElementById('manualItem').value = '';
        }

        function generateEnhancedAnalysis(detection, isManual = false) {
            const confidence = Math.round(detection.score * 100);
            const itemClass = detection.class.toLowerCase();
            
            // MASSIVE enhanced item database
            const enhancedDatabase = {
                // Clothing & Accessories
                'hat': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT CLOTH', desc: 'Hat/headwear', value: '$15-75' },
                'baseball hat': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT CLOTH', desc: 'Baseball cap/hat', value: '$20-60' },
                'winter hat': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT CLOTH', desc: 'Winter hat/beanie', value: '$15-45' },
                'shoes': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT CLOTH', desc: 'Footwear/shoes', value: '$40-300' },
                'coat': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT CLOTH', desc: 'Coat/jacket', value: '$50-400' },
                
                // Tools
                'hammer': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT TOOL', desc: 'Hammer tool', value: '$15-80' },
                'drill': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT TOOL', desc: 'Power drill', value: '$50-300' },
                'wrench': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT TOOL', desc: 'Wrench tool', value: '$10-50' },
                'screwdriver': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT TOOL', desc: 'Screwdriver', value: '$5-25' },
                'saw': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT TOOL', desc: 'Saw tool', value: '$20-200' },
                
                // Electronics
                'printer': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT COMP', desc: 'Computer printer', value: '$80-500' },
                'router': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT COMP', desc: 'Network router', value: '$50-300' },
                'tablet': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT COMP', desc: 'Tablet device', value: '$100-800' },
                'camera': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT ELEC', desc: 'Digital camera', value: '$100-2000' },
                'speaker': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT ELEC', desc: 'Audio speaker', value: '$30-500' },
                
                // Kitchen items
                'blender': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT APPL', desc: 'Kitchen blender', value: '$40-300' },
                'coffee maker': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT APPL', desc: 'Coffee maker', value: '$30-400' },
                'can opener': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT APPL', desc: 'Can opener', value: '$10-40' },
                'mixer': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT APPL', desc: 'Kitchen mixer', value: '$50-400' },
                
                // Standard COCO items with better values
                'chair': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT CHAIR', desc: 'Dining/office chair', value: '$50-400' },
                'couch': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT SOFA', desc: 'Living room sofa', value: '$400-3000' },
                'dining table': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT TABLE', desc: 'Dining table', value: '$200-1500' },
                'bed': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT BED', desc: 'Bed furniture', value: '$300-2500' },
                'tv': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT TV', desc: 'Television', value: '$200-3000' },
                'laptop': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT COMP', desc: 'Laptop computer', value: '$400-3000' },
                'cell phone': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT PHONE', desc: 'Mobile phone', value: '$200-1200' },
                'microwave': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT MICRO', desc: 'Microwave oven', value: '$80-400' },
                'refrigerator': { cat: 'CNT', remove: 'CNT REMOVE', replace: 'CNT REF', desc: 'Kitchen refrigerator', value: '$500-4000' },
                'book': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT BOOKS', desc: 'Books/literature', value: '$5-50 each' },
                'clock': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT DECOR', desc: 'Clock timepiece', value: '$20-300' },
                'bottle': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT MISC', desc: 'Bottle/container', value: '$1-30' },
                'cup': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT DISH', desc: 'Cup/mug', value: '$3-40' },
                'bowl': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT DISH', desc: 'Bowl/dish', value: '$5-50' }
            };
            
            // Find match - try exact first, then partial
            let itemData = enhancedDatabase[itemClass];
            
            if (!itemData) {
                for (const [key, data] of Object.entries(enhancedDatabase)) {
                    if (itemClass.includes(key) || key.includes(itemClass)) {
                        itemData = data;
                        break;
                    }
                }
            }
            
            // Default fallback
            if (!itemData) {
                itemData = {
                    cat: 'CNT',
                    remove: 'CNT PACK',
                    replace: 'CNT MISC',
                    desc: `${detection.class} - personal property item`,
                    value: '$25-200'
                };
            }
            
            return {
                detected_item: detection.class,
                detection_method: isManual ? 'Manual Entry' : 'AI Detection',
                confidence: isManual ? '100% (Manual)' : `${confidence}% (${confidence > 75 ? 'High' : confidence > 55 ? 'Medium' : 'Low'})`,
                xactimate_category: itemData.cat,
                removal_code: itemData.remove,
                replacement_code: itemData.replace,
                description: itemData.desc,
                estimated_value: itemData.value,
                detection_quality: isManual ? 'Manual specification' : (stableDetections.length >= STABILITY_THRESHOLD ? 'Stable AI detection' : 'Needs more stabilization'),
                recommendations: isManual ? 'Manual entry - verify codes as needed' : (confidence > 75 ? 'High confidence - codes ready for use' : 'Verify item and adjust codes if needed'),
                timestamp: new Date().toLocaleString()
            };
        }

        function displayResults(analysis) {
            const resultsEl = document.getElementById('results');
            const contentEl = document.getElementById('resultsContent');
            
            const fields = [
                { key: 'detected_item', label: 'üéØ Item Name', value: analysis.detected_item },
                { key: 'detection_method', label: 'üîç Detection Method', value: analysis.detection_method },
                { key: 'confidence', label: 'üìä Confidence Level', value: analysis.confidence },
                { key: 'xactimate_category', label: 'üìã XACTIMATE Category', value: analysis.xactimate_category },
                { key: 'removal_code', label: 'üì¶ Removal/Packing Code', value: analysis.removal_code },
                { key: 'replacement_code', label: 'üîÑ Replacement Code', value: analysis.replacement_code },
                { key: 'estimated_value', label: 'üí∞ Estimated Value', value: analysis.estimated_value },
                { key: 'description', label: 'üìù Item Description', value: analysis.description },
                { key: 'detection_quality', label: '‚úÖ Detection Quality', value: analysis.detection_quality },
                { key: 'recommendations', label: '‚ö†Ô∏è Recommendations', value: analysis.recommendations },
                { key: 'timestamp', label: 'üïí Analysis Time', value: analysis.timestamp }
            ];
            
            let html = '';
            for (const field of fields) {
                html += `
                    <div class="result-item">
                        <label>${field.label}:</label>
                        <div class="value">${field.value}</div>
                    </div>
                `;
            }
            
            contentEl.innerHTML = html;
            resultsEl.style.display = 'block';
            resultsEl.scrollIntoView({ behavior: 'smooth' });
        }

        // Start the app
        window.addEventListener('load', init);
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (detectionInterval) clearInterval(detectionInterval);
        });
    </script>
</body>
</html>
