<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XM8 Professional - Working Object Detection</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@latest"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: white;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .phase-info {
            background: rgba(34, 197, 94, 0.2);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #22c55e;
        }

        .camera-container {
            position: relative;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(10px);
            margin-bottom: 20px;
        }

        #videoContainer {
            position: relative;
            width: 100%;
            max-width: 640px;
            margin: 0 auto;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        #video {
            width: 100%;
            height: auto;
            display: block;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .controls {
            text-align: center;
            margin: 20px 0;
        }

        #status {
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #captureBtn {
            background: linear-gradient(45deg, #22c55e, #16a34a);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            font-weight: 600;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(34, 197, 94, 0.4);
            display: none;
        }

        #captureBtn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(34, 197, 94, 0.6);
        }

        #captureBtn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .error {
            background: rgba(239, 68, 68, 0.2);
            color: #fecaca;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            border-left: 4px solid #ef4444;
            display: none;
        }

        .results {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            backdrop-filter: blur(10px);
            display: none;
        }

        .results h3 {
            color: #22c55e;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .result-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .result-item {
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #22c55e;
        }

        .result-item label {
            font-weight: 600;
            color: #a3e635;
            display: block;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .result-item .value {
            font-size: 1.1em;
            line-height: 1.4;
            font-family: 'Courier New', monospace;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: #22c55e;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .detection-stats {
            background: rgba(0,0,0,0.3);
            padding: 10px 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .result-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîç XM8 Professional - FIXED</h1>
            <p>Real Object Detection with Dynamic Tracking</p>
            <div class="phase-info">
                <strong>‚úÖ WORKING VERSION:</strong> Real-time object detection with smart item identification
            </div>
        </div>

        <div class="camera-container">
            <div id="videoContainer">
                <video id="video" autoplay playsinline></video>
                <canvas id="canvas"></canvas>
            </div>
            
            <div class="controls">
                <div id="status">üöÄ Initializing camera and AI model...</div>
                <div class="detection-stats" id="detectionStats" style="display: none;">
                    Detecting: <span id="currentDetection">None</span> | 
                    Confidence: <span id="currentConfidence">0%</span> |
                    Stability: <span id="stabilityLevel">0/5</span>
                </div>
                <button id="captureBtn" onclick="captureAndAnalyze()">Analyze Object</button>
            </div>
        </div>

        <div id="error" class="error"></div>

        <div id="results" class="results">
            <h3>üéØ Professional Analysis Results</h3>
            <div id="resultsContent" class="result-grid"></div>
        </div>
    </div>

    <script>
        // Global variables
        let model;
        let video;
        let canvas;
        let ctx;
        let isCapturing = false;
        let detectionInterval;

        // Enhanced detection variables
        let stableDetections = [];
        let currentDetection = null;
        const STABILITY_THRESHOLD = 5;
        const CONFIDENCE_THRESHOLD = 0.5;
        const SMOOTHING_FACTOR = 0.3;

        // Initialize
        async function init() {
            video = document.getElementById('video');
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');

            await initializeCamera();
            await loadModel();
            startDetectionLoop();
        }

        async function initializeCamera() {
            const statusEl = document.getElementById('status');
            const errorEl = document.getElementById('error');
            
            try {
                statusEl.textContent = 'üì∑ Starting camera...';
                errorEl.style.display = 'none';
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
                
                video.srcObject = stream;
                
                video.onloadeddata = () => {
                    // Set canvas to match video size
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    statusEl.textContent = 'ü§ñ Loading AI model...';
                };
                
                return true;
                
            } catch (error) {
                console.error('Camera error:', error);
                let errorMessage = 'Camera Error: ';
                
                if (error.name === 'NotAllowedError') {
                    errorMessage += 'Camera access denied. Please allow camera permission.';
                } else if (error.name === 'NotFoundError') {
                    errorMessage += 'No camera found. Please check your device.';
                } else {
                    errorMessage += error.message;
                }
                
                statusEl.textContent = 'Camera failed';
                errorEl.textContent = errorMessage;
                errorEl.style.display = 'block';
                return false;
            }
        }

        async function loadModel() {
            const statusEl = document.getElementById('status');
            const errorEl = document.getElementById('error');
            
            try {
                statusEl.innerHTML = 'ü§ñ Loading AI model... <div class="loading"></div>';
                model = await cocoSsd.load();
                statusEl.textContent = '‚úÖ Ready! Point camera at any item to detect';
                console.log('COCO-SSD model loaded successfully');
                return true;
            } catch (error) {
                console.error('Model loading failed:', error);
                statusEl.textContent = 'AI model failed to load';
                errorEl.textContent = `Model Error: ${error.message}. Please refresh the page.`;
                errorEl.style.display = 'block';
                return false;
            }
        }

        function startDetectionLoop() {
            if (detectionInterval) clearInterval(detectionInterval);
            
            detectionInterval = setInterval(async () => {
                if (model && video && !isCapturing) {
                    await detectObjects();
                }
            }, 100); // 10 FPS
        }

        async function detectObjects() {
            try {
                const predictions = await model.detect(video);
                const detectionStatsEl = document.getElementById('detectionStats');
                const statusEl = document.getElementById('status');
                
                if (predictions && predictions.length > 0) {
                    // Find the most confident and centered detection
                    const centerX = video.videoWidth / 2;
                    const centerY = video.videoHeight / 2;
                    
                    let bestDetection = null;
                    let bestScore = 0;
                    
                    for (const prediction of predictions) {
                        if (prediction.score > CONFIDENCE_THRESHOLD) {
                            const [x, y, width, height] = prediction.bbox;
                            const objCenterX = x + width / 2;
                            const objCenterY = y + height / 2;
                            
                            // Distance from center
                            const distance = Math.sqrt(
                                Math.pow(objCenterX - centerX, 2) + 
                                Math.pow(objCenterY - centerY, 2)
                            );
                            
                            // Combined score: confidence - distance penalty
                            const combinedScore = prediction.score - (distance / 1000);
                            
                            if (combinedScore > bestScore) {
                                bestScore = combinedScore;
                                bestDetection = prediction;
                            }
                        }
                    }
                    
                    if (bestDetection) {
                        // Smooth the detection if we have a previous one
                        if (currentDetection && currentDetection.class === bestDetection.class) {
                            bestDetection.bbox = smoothBoundingBox(currentDetection.bbox, bestDetection.bbox);
                        }
                        
                        currentDetection = bestDetection;
                        stableDetections.push(bestDetection);
                        
                        // Keep only recent detections
                        if (stableDetections.length > STABILITY_THRESHOLD) {
                            stableDetections.shift();
                        }
                        
                        // Update display
                        drawDetection(bestDetection);
                        updateDetectionStats(bestDetection);
                        detectionStatsEl.style.display = 'block';
                        
                        // Show capture button if stable
                        const captureBtn = document.getElementById('captureBtn');
                        if (stableDetections.length >= STABILITY_THRESHOLD) {
                            captureBtn.style.display = 'block';
                            statusEl.textContent = `üéØ ${bestDetection.class.toUpperCase()} detected and locked - Ready to analyze!`;
                        } else {
                            captureBtn.style.display = 'none';
                            const progress = Math.round((stableDetections.length / STABILITY_THRESHOLD) * 100);
                            statusEl.textContent = `üîç Stabilizing ${bestDetection.class}... ${progress}%`;
                        }
                    } else {
                        resetDetection();
                    }
                } else {
                    resetDetection();
                }
                
            } catch (error) {
                console.error('Detection error:', error);
                document.getElementById('status').textContent = 'Detection error - retrying...';
            }
        }

        function smoothBoundingBox(oldBox, newBox) {
            return [
                oldBox[0] + (newBox[0] - oldBox[0]) * SMOOTHING_FACTOR,
                oldBox[1] + (newBox[1] - oldBox[1]) * SMOOTHING_FACTOR,
                oldBox[2] + (newBox[2] - oldBox[2]) * SMOOTHING_FACTOR,
                oldBox[3] + (newBox[3] - oldBox[3]) * SMOOTHING_FACTOR
            ];
        }

        function drawDetection(detection) {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const [x, y, width, height] = detection.bbox;
            const confidence = Math.round(detection.score * 100);
            const stability = stableDetections.length;
            
            // Determine color based on stability
            let color;
            if (stability >= STABILITY_THRESHOLD) {
                color = '#22c55e'; // Green - ready
            } else if (stability >= 2) {
                color = '#eab308'; // Yellow - getting stable
            } else {
                color = '#f59e0b'; // Orange - just detected
            }
            
            // Draw bounding box with fill
            ctx.strokeStyle = color;
            ctx.fillStyle = color + '20'; // Semi-transparent
            ctx.lineWidth = 3;
            
            // Fill and stroke the rectangle
            ctx.fillRect(x, y, width, height);
            ctx.strokeRect(x, y, width, height);
            
            // Draw corners for better visibility
            const cornerSize = 20;
            ctx.lineWidth = 4;
            
            // Top-left corner
            ctx.beginPath();
            ctx.moveTo(x, y + cornerSize);
            ctx.lineTo(x, y);
            ctx.lineTo(x + cornerSize, y);
            ctx.stroke();
            
            // Top-right corner
            ctx.beginPath();
            ctx.moveTo(x + width - cornerSize, y);
            ctx.lineTo(x + width, y);
            ctx.lineTo(x + width, y + cornerSize);
            ctx.stroke();
            
            // Bottom-left corner
            ctx.beginPath();
            ctx.moveTo(x, y + height - cornerSize);
            ctx.lineTo(x, y + height);
            ctx.lineTo(x + cornerSize, y + height);
            ctx.stroke();
            
            // Bottom-right corner
            ctx.beginPath();
            ctx.moveTo(x + width - cornerSize, y + height);
            ctx.lineTo(x + width, y + height);
            ctx.lineTo(x + width, y + height - cornerSize);
            ctx.stroke();
            
            // Draw center crosshair
            const centerX = x + width / 2;
            const centerY = y + height / 2;
            const crossSize = Math.min(width, height) * 0.1;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX - crossSize, centerY);
            ctx.lineTo(centerX + crossSize, centerY);
            ctx.moveTo(centerX, centerY - crossSize);
            ctx.lineTo(centerX, centerY + crossSize);
            ctx.stroke();
            
            // Draw label
            const label = `${detection.class.toUpperCase()} - ${confidence}%`;
            const labelY = y > 30 ? y - 10 : y + height + 25;
            
            // Label background
            const textMetrics = ctx.measureText(label);
            ctx.fillStyle = color;
            ctx.fillRect(x - 2, labelY - 20, textMetrics.width + 10, 25);
            
            // Label text
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px Arial';
            ctx.fillText(label, x + 3, labelY - 3);
        }

        function updateDetectionStats(detection) {
            document.getElementById('currentDetection').textContent = detection.class;
            document.getElementById('currentConfidence').textContent = Math.round(detection.score * 100) + '%';
            document.getElementById('stabilityLevel').textContent = `${stableDetections.length}/${STABILITY_THRESHOLD}`;
        }

        function resetDetection() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            stableDetections = [];
            currentDetection = null;
            document.getElementById('captureBtn').style.display = 'none';
            document.getElementById('detectionStats').style.display = 'none';
            document.getElementById('status').textContent = 'üîç Scanning for objects... Point camera at items';
        }

        async function captureAndAnalyze() {
            if (!currentDetection || isCapturing) return;
            
            isCapturing = true;
            const captureBtn = document.getElementById('captureBtn');
            const statusEl = document.getElementById('status');
            const errorEl = document.getElementById('error');
            
            try {
                errorEl.style.display = 'none';
                captureBtn.textContent = 'Analyzing...';
                captureBtn.disabled = true;
                statusEl.textContent = 'üì∏ Capturing and analyzing...';
                
                // Simulate analysis delay
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                // Generate comprehensive analysis
                const analysis = generateDetailedAnalysis(currentDetection);
                
                statusEl.textContent = '‚úÖ Analysis complete!';
                displayResults(analysis);
                
            } catch (error) {
                console.error('Analysis error:', error);
                statusEl.textContent = 'Analysis failed - try again';
                errorEl.textContent = `Analysis Error: ${error.message}`;
                errorEl.style.display = 'block';
            } finally {
                isCapturing = false;
                captureBtn.textContent = 'Analyze Object';
                captureBtn.disabled = false;
            }
        }

        function generateDetailedAnalysis(detection) {
            const confidence = Math.round(detection.score * 100);
            const itemClass = detection.class.toLowerCase();
            
            // Comprehensive item database
            const itemDatabase = {
                'person': { cat: 'N/A', remove: 'N/A', replace: 'N/A', desc: 'Person detected - not applicable for contents', value: 'N/A' },
                'chair': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT CHAIR', desc: 'Dining/office chair', value: '$50-300' },
                'couch': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT SOFA', desc: 'Living room sofa/couch', value: '$500-2500' },
                'dining table': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT TABLE', desc: 'Dining room table', value: '$200-1000' },
                'potted plant': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT PLANT', desc: 'Decorative plant', value: '$20-150' },
                'bed': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT BED', desc: 'Bedroom furniture', value: '$300-2000' },
                'toilet': { cat: 'PLB', remove: 'PLB DEMO', replace: 'PLB TOILET', desc: 'Bathroom toilet', value: '$150-800' },
                'tv': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT TV', desc: 'Television/monitor', value: '$200-2000' },
                'laptop': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT COMP', desc: 'Laptop computer', value: '$400-2500' },
                'mouse': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT COMP', desc: 'Computer mouse', value: '$15-100' },
                'remote': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT ELEC', desc: 'TV/device remote', value: '$10-50' },
                'keyboard': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT COMP', desc: 'Computer keyboard', value: '$30-200' },
                'cell phone': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT PHONE', desc: 'Mobile phone', value: '$200-1200' },
                'microwave': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT MICRO', desc: 'Microwave oven', value: '$80-400' },
                'oven': { cat: 'CNT', remove: 'CNT REMOVE', replace: 'CNT RANGE', desc: 'Cooking range/oven', value: '$400-2000' },
                'toaster': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT APPL', desc: 'Toaster appliance', value: '$25-150' },
                'sink': { cat: 'PLB', remove: 'PLB DEMO', replace: 'PLB SINK', desc: 'Kitchen/bathroom sink', value: '$100-600' },
                'refrigerator': { cat: 'CNT', remove: 'CNT REMOVE', replace: 'CNT REF', desc: 'Kitchen refrigerator', value: '$500-3000' },
                'book': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT BOOKS', desc: 'Books/literature', value: '$5-50 each' },
                'clock': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT DECOR', desc: 'Wall/desk clock', value: '$20-200' },
                'vase': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT DECOR', desc: 'Decorative vase', value: '$15-300' },
                'scissors': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT MISC', desc: 'Scissors/cutting tool', value: '$5-30' },
                'teddy bear': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT TOY', desc: 'Stuffed animal/toy', value: '$10-100' },
                'hair drier': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT APPL', desc: 'Hair dryer appliance', value: '$25-200' },
                'toothbrush': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT PERS', desc: 'Personal hygiene item', value: '$2-20' },
                'wine glass': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT DISH', desc: 'Glassware/stemware', value: '$5-50 each' },
                'cup': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT DISH', desc: 'Cups/mugs', value: '$3-25 each' },
                'fork': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT DISH', desc: 'Cutlery/utensils', value: '$1-10 each' },
                'knife': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT DISH', desc: 'Kitchen knife/cutlery', value: '$5-100' },
                'spoon': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT DISH', desc: 'Cutlery/utensils', value: '$1-10 each' },
                'bowl': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT DISH', desc: 'Bowls/dinnerware', value: '$3-30 each' },
                'banana': { cat: 'CNT', remove: 'CNT DISPOSE', replace: 'CNT FOOD', desc: 'Perishable food item', value: '$1-5' },
                'apple': { cat: 'CNT', remove: 'CNT DISPOSE', replace: 'CNT FOOD', desc: 'Perishable food item', value: '$1-5' },
                'sandwich': { cat: 'CNT', remove: 'CNT DISPOSE', replace: 'CNT FOOD', desc: 'Perishable food item', value: '$5-15' },
                'orange': { cat: 'CNT', remove: 'CNT DISPOSE', replace: 'CNT FOOD', desc: 'Perishable food item', value: '$1-5' },
                'broccoli': { cat: 'CNT', remove: 'CNT DISPOSE', replace: 'CNT FOOD', desc: 'Perishable food item', value: '$2-8' },
                'carrot': { cat: 'CNT', remove: 'CNT DISPOSE', replace: 'CNT FOOD', desc: 'Perishable food item', value: '$1-5' },
                'bottle': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT MISC', desc: 'Bottles/containers', value: '$1-20 each' },
                'backpack': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT BAG', desc: 'Bags/luggage', value: '$30-200' },
                'umbrella': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT MISC', desc: 'Personal umbrella', value: '$10-80' },
                'handbag': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT BAG', desc: 'Purse/handbag', value: '$25-500' },
                'tie': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT CLOTH', desc: 'Clothing/accessories', value: '$10-100' },
                'suitcase': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT BAG', desc: 'Luggage/suitcase', value: '$50-400' },
                'frisbee': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT TOY', desc: 'Recreational item', value: '$5-25' },
                'skis': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT SPORT', desc: 'Ski equipment', value: '$100-800' },
                'snowboard': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT SPORT', desc: 'Snowboard equipment', value: '$150-1000' },
                'sports ball': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT SPORT', desc: 'Sports equipment', value: '$10-100' },
                'kite': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT TOY', desc: 'Recreational kite', value: '$5-50' },
                'baseball bat': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT SPORT', desc: 'Baseball equipment', value: '$20-200' },
                'baseball glove': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT SPORT', desc: 'Baseball glove', value: '$25-300' },
                'skateboard': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT SPORT', desc: 'Skateboard', value: '$50-300' },
                'surfboard': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT SPORT', desc: 'Surfboard', value: '$200-1500' },
                'tennis racket': { cat: 'CNT', remove: 'CNT PACK', replace: 'CNT SPORT', desc: 'Tennis racket', value: '$30-400' }
            };
            
            // Get item data or use default
            const itemData = itemDatabase[itemClass] || {
                cat: 'CNT', 
                remove: 'CNT PACK', 
                replace: 'CNT MISC', 
                desc: `${detection.class} - manual classification needed`,
                value: 'Manual appraisal required'
            };
            
            return {
                detected_item: detection.class,
                confidence: `${confidence}%`,
                confidence_level: confidence > 75 ? 'High' : confidence > 55 ? 'Medium' : 'Low',
                xactimate_category: itemData.cat,
                removal_code: itemData.remove,
                replacement_code: itemData.replace,
                description: itemData.desc,
                estimated_value: itemData.value,
                detection_quality: stableDetections.length >= STABILITY_THRESHOLD ? 'Stable detection' : 'Needs stabilization',
                recommended_action: confidence > 75 ? 'Codes ready for use' : 'Manual verification recommended',
                timestamp: new Date().toLocaleString()
            };
        }

        function displayResults(analysis) {
            const resultsEl = document.getElementById('results');
            const contentEl = document.getElementById('resultsContent');
            
            const fields = [
                { key: 'detected_item', label: 'üéØ Detected Item', value: analysis.detected_item },
                { key: 'confidence', label: 'üìä Detection Confidence', value: `${analysis.confidence} (${analysis.confidence_level})` },
                { key: 'xactimate_category', label: 'üìã XACTIMATE Category', value: analysis.xactimate_category },
                { key: 'removal_code', label: 'üì¶ Removal/Packing Code', value: analysis.removal_code },
                { key: 'replacement_code', label: 'üîÑ Replacement Code', value: analysis.replacement_code },
                { key: 'estimated_value', label: 'üí∞ Estimated Value', value: analysis.estimated_value },
                { key: 'description', label: 'üìù Item Description', value: analysis.description },
                { key: 'detection_quality', label: '‚úÖ Detection Quality', value: analysis.detection_quality },
                { key: 'recommended_action', label: '‚ö†Ô∏è Recommendation', value: analysis.recommended_action },
                { key: 'timestamp', label: 'üïí Analysis Time', value: analysis.timestamp }
            ];
            
            let html = '';
            for (const field of fields) {
                html += `
                    <div class="result-item">
                        <label>${field.label}:</label>
                        <div class="value">${field.value}</div>
                    </div>
                `;
            }
            
            contentEl.innerHTML = html;
            resultsEl.style.display = 'block';
            resultsEl.scrollIntoView({ behavior: 'smooth' });
        }

        // Start the app
        window.addEventListener('load', init);
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (detectionInterval) clearInterval(detectionInterval);
        });
    </script>
</body>
</html>
