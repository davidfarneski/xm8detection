<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XM8 Detection - Universal Building & Contents Identification</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@latest"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .camera-container {
            position: relative;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(10px);
            margin-bottom: 20px;
        }

        #videoContainer {
            position: relative;
            width: 100%;
            max-width: 640px;
            margin: 0 auto;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        #video {
            width: 100%;
            height: auto;
            display: block;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .center-guide {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            border: 2px dashed rgba(255,255,255,0.5);
            border-radius: 10px;
            pointer-events: none;
        }

        .center-guide::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.7);
            border-radius: 50%;
        }

        .controls {
            text-align: center;
            margin: 20px 0;
        }

        #status {
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #captureBtn {
            background: linear-gradient(45deg, #22c55e, #16a34a);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            font-weight: 600;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(34, 197, 94, 0.4);
            display: none;
        }

        #captureBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(34, 197, 94, 0.6);
        }

        #captureBtn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .error {
            background: rgba(239, 68, 68, 0.2);
            color: #fecaca;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            border-left: 4px solid #ef4444;
            display: none;
        }

        .results {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            backdrop-filter: blur(10px);
            display: none;
        }

        .results h3 {
            color: #22c55e;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .result-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .result-item {
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #22c55e;
        }

        .result-item label {
            font-weight: 600;
            color: #a3e635;
            display: block;
            margin-bottom: 5px;
        }

        .result-item value {
            font-size: 1.1em;
            font-family: 'Courier New', monospace;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .result-grid {
                grid-template-columns: 1fr;
            }
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: #22c55e;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè† XM8 Detection</h1>
            <p>Universal Building & Contents Identification with XACTIMATE Codes</p>
        </div>

        <div class="camera-container">
            <div id="videoContainer">
                <video id="video" autoplay playsinline></video>
                <canvas id="canvas"></canvas>
                <div class="center-guide"></div>
            </div>
            
            <div class="controls">
                <div id="status">üöÄ Initializing camera and AI model...</div>
                <button id="captureBtn" onclick="captureAndAnalyze()">Analyze Object</button>
            </div>
        </div>

        <div id="error" class="error"></div>

        <div id="results" class="results">
            <h3>üéØ Detection Results</h3>
            <div id="resultsContent" class="result-grid"></div>
        </div>
    </div>

    <script>
        // Global variables
        let model;
        let video;
        let canvas;
        let ctx;
        let isCapturing = false;

        // Enhanced stabilization variables
        let stableDetections = [];
        let frameCount = 0;
        let lastStableBox = null;
        const STABILITY_THRESHOLD = 8;
        const DETECTION_CONFIDENCE = 0.4;
        const BOX_SMOOTHING = 0.7;

        // Initialize the app
        async function init() {
            video = document.getElementById('video');
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');

            // Initialize camera
            const cameraSuccess = await initializeCamera();
            if (!cameraSuccess) return;

            // Load model
            await loadModel();
            
            // Start detection loop
            detectObjects();
            setInterval(detectObjects, 100); // 10 FPS detection
        }

        async function initializeCamera() {
            const statusEl = document.getElementById('status');
            const errorEl = document.getElementById('error');
            
            try {
                statusEl.textContent = 'üì∑ Starting camera...';
                errorEl.style.display = 'none';
                
                // Request camera access with better settings
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
                
                video.srcObject = stream;
                video.onloadeddata = () => {
                    statusEl.textContent = 'ü§ñ Loading AI model...';
                    // Set canvas size to match video
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                };
                
                return true;
                
            } catch (error) {
                console.error('Camera initialization failed:', error);
                
                let errorMessage = 'Camera Error: ';
                if (error.name === 'NotAllowedError') {
                    errorMessage += 'Camera access denied. Please allow camera permission and refresh.';
                } else if (error.name === 'NotFoundError') {
                    errorMessage += 'No camera found. Please check your device.';
                } else if (error.name === 'NotReadableError') {
                    errorMessage += 'Camera is in use by another app. Please close other apps and try again.';
                } else {
                    errorMessage += error.message;
                }
                
                statusEl.textContent = 'Camera setup failed';
                errorEl.textContent = errorMessage;
                errorEl.style.display = 'block';
                
                return false;
            }
        }

        async function loadModel() {
            const statusEl = document.getElementById('status');
            const errorEl = document.getElementById('error');
            
            try {
                statusEl.innerHTML = 'ü§ñ Loading AI model... <div class="loading"></div>';
                model = await cocoSsd.load();
                statusEl.textContent = 'üì± Position object in center of frame';
                console.log('Model loaded successfully');
            } catch (error) {
                console.error('Model loading failed:', error);
                statusEl.textContent = 'AI model failed to load';
                errorEl.textContent = `Model Error: ${error.message}. Please refresh the page.`;
                errorEl.style.display = 'block';
            }
        }

        async function detectObjects() {
            if (!model || isCapturing) return;
            
            frameCount++;
            
            try {
                const predictions = await model.detect(video);
                
                if (predictions && predictions.length > 0) {
                    // Filter and find the most centered object
                    const centerX = video.videoWidth / 2;
                    const centerY = video.videoHeight / 2;
                    
                    // Find object closest to center with good confidence
                    let bestDetection = null;
                    let minDistance = Infinity;
                    
                    for (const prediction of predictions) {
                        if (prediction.score > DETECTION_CONFIDENCE) {
                            const [x, y, width, height] = prediction.bbox;
                            const objCenterX = x + width / 2;
                            const objCenterY = y + height / 2;
                            const distance = Math.sqrt(
                                Math.pow(objCenterX - centerX, 2) + 
                                Math.pow(objCenterY - centerY, 2)
                            );
                            
                            if (distance < minDistance) {
                                minDistance = distance;
                                bestDetection = prediction;
                            }
                        }
                    }
                    
                    if (bestDetection) {
                        // Smooth the detection box if we have a previous one
                        if (lastStableBox) {
                            const [newX, newY, newW, newH] = bestDetection.bbox;
                            const [oldX, oldY, oldW, oldH] = lastStableBox;
                            
                            bestDetection.bbox = [
                                oldX + (newX - oldX) * BOX_SMOOTHING,
                                oldY + (newY - oldY) * BOX_SMOOTHING,
                                oldW + (newW - oldW) * BOX_SMOOTHING,
                                oldH + (newH - oldH) * BOX_SMOOTHING
                            ];
                        }
                        
                        lastStableBox = bestDetection.bbox;
                        stableDetections.push(bestDetection);
                        
                        // Keep only recent detections
                        if (stableDetections.length > STABILITY_THRESHOLD) {
                            stableDetections.shift();
                        }
                        
                        drawPrediction(bestDetection);
                        updateStatus();
                    } else {
                        // No good detection found
                        stableDetections = [];
                        lastStableBox = null;
                        clearCanvas();
                        document.getElementById('status').textContent = 'Position object in center of frame';
                        document.getElementById('captureBtn').style.display = 'none';
                    }
                } else {
                    // No predictions
                    stableDetections = [];
                    lastStableBox = null;
                    clearCanvas();
                    document.getElementById('status').textContent = 'Scanning for objects...';
                    document.getElementById('captureBtn').style.display = 'none';
                }
            } catch (error) {
                console.error('Detection error:', error);
                document.getElementById('status').textContent = 'Detection error - retrying...';
            }
        }

        function updateStatus() {
            const statusEl = document.getElementById('status');
            const captureBtn = document.getElementById('captureBtn');
            
            if (stableDetections.length >= STABILITY_THRESHOLD) {
                statusEl.textContent = 'üéØ Object locked - Ready to analyze!';
                captureBtn.style.display = 'block';
                captureBtn.style.backgroundColor = '#22c55e';
            } else if (stableDetections.length > 0) {
                const progress = Math.round((stableDetections.length / STABILITY_THRESHOLD) * 100);
                statusEl.textContent = `üîç Stabilizing... ${progress}%`;
                captureBtn.style.display = 'none';
            } else {
                statusEl.textContent = 'üì± Position object in center of frame';
                captureBtn.style.display = 'none';
            }
        }

        function drawPrediction(prediction) {
            clearCanvas();
            
            const [x, y, width, height] = prediction.bbox;
            const confidence = prediction.score;
            
            // Determine stable color based on detection quality
            let color, status;
            if (stableDetections.length >= STABILITY_THRESHOLD) {
                color = '#22c55e'; // Stable green
                status = 'READY';
            } else if (stableDetections.length >= STABILITY_THRESHOLD * 0.6) {
                color = '#eab308'; // Warning yellow  
                status = 'STABILIZING';
            } else {
                color = '#ef4444'; // Needs adjustment red
                status = 'CENTERING';
            }
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color + '20'; // Semi-transparent fill
            ctx.lineWidth = 3;
            
            // Draw filled rectangle with border
            ctx.fillRect(x, y, width, height);
            ctx.strokeRect(x, y, width, height);
            
            // Draw center crosshair
            const centerX = x + width / 2;
            const centerY = y + height / 2;
            const crossSize = 20;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX - crossSize, centerY);
            ctx.lineTo(centerX + crossSize, centerY);
            ctx.moveTo(centerX, centerY - crossSize);
            ctx.lineTo(centerX, centerY + crossSize);
            ctx.stroke();
            
            // Draw label with better visibility
            const label = `${prediction.class} (${Math.round(confidence * 100)}%) - ${status}`;
            const labelY = y > 40 ? y - 10 : y + height + 25;
            
            ctx.fillStyle = color;
            ctx.fillRect(x, labelY - 20, ctx.measureText(label).width + 10, 25);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px Arial';
            ctx.fillText(label, x + 5, labelY - 3);
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        async function captureAndAnalyze() {
            if (isCapturing || stableDetections.length < STABILITY_THRESHOLD) {
                return;
            }
            
            isCapturing = true;
            const captureBtn = document.getElementById('captureBtn');
            const statusEl = document.getElementById('status');
            const errorEl = document.getElementById('error');
            
            try {
                // Hide previous errors
                errorEl.style.display = 'none';
                
                // Update UI
                captureBtn.textContent = 'Analyzing...';
                captureBtn.disabled = true;
                statusEl.textContent = 'üì∏ Capturing image...';
                
                // Create canvas for capture
                const captureCanvas = document.createElement('canvas');
                const captureCtx = captureCanvas.getContext('2d');
                
                // Set canvas size to match video
                captureCanvas.width = video.videoWidth;
                captureCanvas.height = video.videoHeight;
                
                // Draw the current video frame
                captureCtx.drawImage(video, 0, 0);
                
                // Get image data
                const imageData = captureCanvas.toDataURL('image/jpeg', 0.8);
                
                // Analyze with vision
                await analyzeWithVision(imageData);
                
            } catch (error) {
                console.error('Capture error:', error);
                statusEl.textContent = 'Capture failed - try again';
                errorEl.textContent = `Capture Error: ${error.message}`;
                errorEl.style.display = 'block';
            } finally {
                // Reset UI
                isCapturing = false;
                captureBtn.textContent = 'Analyze Object';
                captureBtn.disabled = false;
                
                // Only show capture button if still stable
                if (stableDetections.length >= STABILITY_THRESHOLD) {
                    captureBtn.style.display = 'block';
                    statusEl.textContent = 'üéØ Object locked - Ready to analyze!';
                } else {
                    captureBtn.style.display = 'none';
                    statusEl.textContent = 'üì± Position object in center of frame';
                }
            }
        }

        async function analyzeWithVision(imageData) {
            const statusEl = document.getElementById('status');
            const errorEl = document.getElementById('error');
            const resultsEl = document.getElementById('results');
            
            try {
                statusEl.textContent = 'Analyzing with AI Vision...';
                errorEl.style.display = 'none';
                
                // Convert canvas to base64
                const base64Image = imageData.split(',')[1];
                
                const response = await fetch('/api/analyze-vision', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        image: base64Image,
                        mimeType: 'image/jpeg'
                    }),
                    timeout: 30000
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
                }

                const result = await response.json();
                
                if (result.success && result.analysis) {
                    statusEl.textContent = 'Analysis complete!';
                    displayResults(result.analysis);
                } else {
                    throw new Error(result.error || 'Unknown analysis error');
                }

            } catch (error) {
                console.error('Vision analysis error:', error);
                statusEl.textContent = 'Ready to capture';
                
                let errorMessage = 'Analysis failed: ';
                if (error.message.includes('timeout')) {
                    errorMessage += 'Request timed out. Please try again.';
                } else if (error.message.includes('network')) {
                    errorMessage += 'Network error. Check your connection.';
                } else if (error.message.includes('HTTP 4')) {
                    errorMessage += 'Authentication issue. Check API key.';
                } else if (error.message.includes('HTTP 5')) {
                    errorMessage += 'Server error. Try again in a moment.';
                } else {
                    errorMessage += error.message;
                }
                
                errorEl.textContent = errorMessage;
                errorEl.style.display = 'block';
                
                // Show fallback basic analysis
                displayBasicAnalysis();
            }
        }

        function displayBasicAnalysis() {
            const resultsEl = document.getElementById('results');
            const basicAnalysis = {
                material: "Material detected - needs manual verification",
                category: "RFG",
                removal_code: "RFG RES",
                replacement_code: "RFG NEW", 
                description: "Use manual identification for precise codes",
                confidence: "Basic Detection",
                notes: "For accurate XACTIMATE codes, improve lighting and try again"
            };
            
            displayResults(basicAnalysis);
        }

        function displayResults(analysis) {
            const resultsContainer = document.getElementById('results');
            const resultsContent = document.getElementById('resultsContent');
            
            if (!analysis) return;
            
            // Parse the analysis if it's a string
            let data = analysis;
            if (typeof analysis === 'string') {
                try {
                    data = JSON.parse(analysis);
                } catch (e) {
                    // If not JSON, create basic structure
                    data = {
                        material: analysis,
                        category: "Unknown",
                        removal_code: "Manual lookup needed",
                        replacement_code: "Manual lookup needed"
                    };
                }
            }
            
            // Create results HTML
            let resultsHTML = '';
            
            const fields = [
                { key: 'material', label: 'Material Type' },
                { key: 'category', label: 'XACTIMATE Category' },
                { key: 'removal_code', label: 'Removal Code' },
                { key: 'replacement_code', label: 'Replacement Code' },
                { key: 'description', label: 'Description' },
                { key: 'confidence', label: 'Confidence' },
                { key: 'notes', label: 'Notes' }
            ];
            
            for (const field of fields) {
                if (data[field.key]) {
                    resultsHTML += `
                        <div class="result-item">
                            <label>${field.label}:</label>
                            <value>${data[field.key]}</value>
                        </div>
                    `;
                }
            }
            
            resultsContent.innerHTML = resultsHTML;
            resultsContainer.style.display = 'block';
            
            // Scroll to results
            resultsContainer.scrollIntoView({ behavior: 'smooth' });
        }

        // Start the app when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
